import { cleanupEventHandlers } from '@/bridge/events/cleanupEventHandlers.js';
import { defineEventHandlers } from '@/bridge/events/defineEventHandlers.js';
import type { MiniAppsEventName } from '@/bridge/events/types/index.js';
import { parseMessage } from '@/bridge/parseMessage.js';
import { log } from '@/debug/debug.js';
import { EventEmitter } from '@/events/event-emitter/EventEmitter.js';
import { onWindow } from '@/events/onWindow.js';
import { compose } from '@/misc/compose.js';

export type Emitter = EventEmitter<Record<MiniAppsEventName | string, unknown>>;

/**
 * Creates new event emitter, which handles events from the Telegram application and emits
 * the "message" event containing event data raw representation.
 */
export function createEmitter(): [
  /**
   * Created event emitter.
   */
  emitter: Emitter,
  /**
   * Function to dispose created emitter.
   */
  dispose: () => void,
] {
  const emitter: Emitter = new EventEmitter();

  // Define global Mini Apps event handlers to make sure, we will be able to process them
  // locally.
  defineEventHandlers();

  return [
    emitter,
    compose(
      // Don't forget to remove them when they became unnecessary.
      cleanupEventHandlers,
      // Add "resize" event listener to make sure, we always have fresh viewport information.
      // Desktop version of Telegram is sometimes not sending the viewport_changed
      // event. For example, when the MainButton is shown. That's why we should
      // add our own listener to make sure, viewport information is always fresh.
      // Issue: https://github.com/Telegram-Mini-Apps/tma.js/issues/10
      onWindow('resize', () => {
        emitter.emit('viewport_changed', {
          width: window.innerWidth,
          height: window.innerHeight,
          is_state_stable: true,
          is_expanded: true,
        });
      }),
      // Add listener, which handles events sent from the Telegram web application and also events
      // generated by the local emitEvent function.
      onWindow('message', (event) => {
        if (event.source === window.parent) {
          try {
            const message = parseMessage(event.data);
            log('rawEvent', 'Received raw event:', message);
            emitter.emit(message.eventType, message.eventData);
          } catch {
            // We ignore incorrect messages as they could be generated by any other code.
          }
        }
      }),
      // Clear emitter bound events.
      () => emitter.clear(),
    ),
  ];
}
